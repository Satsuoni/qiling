#!/usr/bin/env python3
# 
# Cross Platform and Multi Architecture Advanced Binary Emulation Framework
#

# Subsystems which program may communicate to 
# generated by MIG
# We can find the defines in /usr/include/mach/*.defs
# Now we havent finish the server it self, only return the fixed data
# TODO: finish the servers
# find Release source code in https://github.com/doadam/xnu-4570.1.46/master/BUILD/obj/RELEASE_X86_64/osfmk/RELEASE/mach/mach_host_server.c

from struct import pack, unpack

from qiling.const import *
from .mach_port import *
from .const import *
MACH_MSGH_BITS_COMPLEX = 0x80000000
class MachHostServer():

    def __init__(self, ql):
        self.ql = ql
        self.system_rpc = {
            200: self.host_info,
            206: self.host_get_clock_service
        }
        pass

    def host_info(self, in_header, in_content):
        # parse request
        out_msg = MachMsg(self.ql)
        if len(in_content) < 16:
            self.ql.log.debug("Error in Host info SubSystem -hostinfo()")
            raise
        ndr = unpack("<Q", in_content[:8])[0]
        flavor = unpack("<L", in_content[8:12])[0]
        host_info_outCnt = unpack("<L", in_content[12:16])[0]
        # may be we need wapper a func in kernel func ,but it is also a huge projrct 
        # gen reply

        if flavor == HOST_BASIC_INFO:
            out_msg.header.msgh_bits = 4608
            out_msg.header.msgh_size = 88
            out_msg.header.msgh_remote_port = 0
            out_msg.header.msgh_local_port = self.ql.os.macho_mach_port.name
            out_msg.header.msgh_voucher_port = 0
            out_msg.header.msgh_id = 300

            out_msg.content += pack("<Q", 0x100000000)      # NDR
            out_msg.content += pack("<L", 0x0)              # ret code / KERN SUCCESS
            out_msg.content += pack("<L", host_info_outCnt) # host info output count 

            # host info out
            out_msg.content += pack("<L", 0x2)              # max_cpus
            out_msg.content += pack("<L", 0x2)              # avail_cpus
            out_msg.content += pack("<L", 0x80000000)       # memory_size
            out_msg.content += pack("<L", 0x7)              # cpu_type
            out_msg.content += pack("<L", 0x4)              # cpu_subtype
            if host_info_outCnt > 5:
                out_msg.content += pack("<L", 0x1)          # cpu_threadtype
                out_msg.content += pack("<L", 0x2)          # physical_cpu
                out_msg.content += pack("<L", 0x2)          # physical_cpu_max
                out_msg.content += pack("<L", 0x4)          # logic_cpu
                out_msg.content += pack("<L", 0x4)          # logic_cpu_max
                out_msg.content += pack("<Q", 0x400000000)  # max_mem
            
        elif flavor == HOST_PRIORITY_INFO:
            out_msg.header.msgh_bits = 4608
            out_msg.header.msgh_size = 72
            out_msg.header.msgh_remote_port = 0
            out_msg.header.msgh_local_port = self.ql.os.macho_mach_port.name
            out_msg.header.msgh_voucher_port = 0
            out_msg.header.msgh_id = 300

            out_msg.content += pack("<Q", 0x100000000)      # NDR
            out_msg.content += pack("<L", 0x0)              # ret code / KERN SUCCESS
            out_msg.content += pack("<L", host_info_outCnt) # host info output count 
            # host info out
            out_msg.content += pack("<L", 0x50)             # kernel_priority = MINPRI_KERNEL;
            out_msg.content += pack("<L", 0x50)             # system_priority = MINPRI_KERNEL;
            out_msg.content += pack("<L", 0x40)             # server_priority = MINPRI_RESERVED;
            out_msg.content += pack("<L", 0x1f)             # user_priority = BASEPRI_DEFAULT;
            out_msg.content += pack("<L", 0x0)              # depress_priority = DEPRESSPRI;
            out_msg.content += pack("<L", 0x0)              # idle_priority = IDLEPRI;
            out_msg.content += pack("<L", 0x0)              # minimum_priority = MINPRI_USER;
            out_msg.content += pack("<L", 0x4f)             # maximum_priority = MAXPRI_RESERVED
        else:
            self.ql.log.debug("Host flavor not support")
            raise
        return out_msg
    """
    	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body; #mach_msg_body_t:4ul
		mach_msg_port_descriptor_t port; 12 ul
		/* end of the kernel processed data */
	} __Reply__host_get_special_port_t __attribute__((unused));
    """
    def host_get_special_port(self,in_header, in_content):
        out_msg = MachMsg(self.ql)
        out_msg.header.msgh_bits = 0x80001200
        out_msg.header.msgh_remote_port =0
        out_msg.header.msgh_voucher_port = 0
        out_msg.header.msgh_local_port = self.ql.os.macho_mach_port.name
        out_msg.header.msgh_size=40
        out_msg.header.msgh_id = in_header.msgh_id+100
        out_msg.content = pack("<L", 0x1)
        out_msg.trailer = b''
        out_msg.trailer += pack("<L",self.ql.os.macho_port_manager.host_port.name)       # host port name 
        out_msg.trailer += pack("<L", 0x0)                                             # pad1
        out_msg.trailer += pack("<H", 0x0)                                              # pad2
        out_msg.trailer += pack("<B", 19)                                             # disposition
        out_msg.trailer += pack("<B", 0x0)                                              # type
        out_msg.trailer += pack("<L", 0x0)                                              # pad end
        return out_msg

    def host_get_clock_service(self, in_header, in_content):
        out_msg = MachMsg(self.ql)

        out_msg.header.msgh_bits = 0x80001200
        out_msg.header.msgh_size = 0x00000028
        out_msg.header.msgh_remote_port = 0x00000000
        out_msg.header.msgh_local_port = self.ql.os.macho_mach_port.name
        out_msg.header.msgh_voucher_port = 0
        out_msg.header.msgh_id = 306

        out_msg.content = pack("<L", 0x1)

        out_msg.trailer = b''
        out_msg.trailer += pack("<L", self.ql.os.macho_port_manager.clock_port.name)       # clock port name 
        out_msg.trailer += pack("<L", 0x0)                                              # pad1
        out_msg.trailer += pack("<H", 0x0)                                              # pad2
        out_msg.trailer += pack("<B", 0x11)                                             # disposition
        out_msg.trailer += pack("<B", 0x0)                                              # type
        out_msg.trailer += pack("<L", 0x0)                                              # pad end
        
        return out_msg

TASK_AUDIT_TOKEN      =          15
TASK_EXTMOD_INFO   =19
ARM_DEBUG_STATE32    =    14
ARM_DEBUG_STATE64    =   15
TASK_DYLD_INFO       =     17
"""
struct task_dyld_info {
	mach_vm_address_t       all_image_info_addr;
	mach_vm_size_t          all_image_info_size;
	integer_t               all_image_info_format;
};
typedef struct task_dyld_info   task_dyld_info_data_t;
typedef struct task_dyld_info   *task_dyld_info_t;
"""
"""
x86_debug_state64_t - 64 bytes
struct vm_extmod_statistics {
	int64_t task_for_pid_count;                     /* # of times task port was looked up */
	int64_t task_for_pid_caller_count;      /* # of times this task called task_for_pid */
	int64_t thread_creation_count;          /* # of threads created in task */
	int64_t thread_creation_caller_count;   /* # of threads created by task */
	int64_t thread_set_state_count;         /* # of register state sets in task */
	int64_t thread_set_state_caller_count;  /* # of register state sets by task */
} __attribute__((aligned(8)));
struct task_extmod_info {
	unsigned char   task_uuid[16];
	vm_extmod_statistics_data_t             extmod_statistics;
}; - 64 bytes
_STRUCT_X86_DEBUG_STATE32
{
	unsigned int	__dr0;
	unsigned int	__dr1;
	unsigned int	__dr2;
	unsigned int	__dr3;
	unsigned int	__dr4;
	unsigned int	__dr5;
	unsigned int	__dr6;
	unsigned int	__dr7;
};
_STRUCT_X86_DEBUG_STATE64
{
	__uint64_t	__dr0;
	__uint64_t	__dr1;
	__uint64_t	__dr2;
	__uint64_t	__dr3;
	__uint64_t	__dr4;
	__uint64_t	__dr5;
	__uint64_t	__dr6;
	__uint64_t	__dr7;
};
"""
x86_DEBUG_STATE32        =       10
x86_DEBUG_STATE64        =       11
class MachTaskServer():

    def __init__(self, ql):
        self.ql = ql
        
    def semaphore_create(self, in_header, in_content):
        out_msg = MachMsg(self.ql)

        out_msg.header.msgh_bits = 0x80001200
        out_msg.header.msgh_size = 0x00000028
        out_msg.header.msgh_remote_port = 0x00000000
        out_msg.header.msgh_local_port = self.ql.os.macho_mach_port.name
        out_msg.header.msgh_voucher_port = 0
        out_msg.header.msgh_id = 3518

        out_msg.content = pack("<L", 0x1)

        out_msg.trailer = b''
        out_msg.trailer += pack("<L", self.ql.os.macho_port_manager.semaphore_port.name)       # clock port name 
        out_msg.trailer += pack("<L", 0x0)                                                  # pad1
        out_msg.trailer += pack("<H", 0x0)                                                  # pad2
        out_msg.trailer += pack("<B", 0x11)                                                 # disposition
        out_msg.trailer += pack("<B", 0x0)                                                  # type
        out_msg.trailer += pack("<L", 0x0)                                                  # pad end
         
        return out_msg
    """
    	typedef struct {
		mach_msg_header_t Head; 24
		NDR_record_t NDR; 8 
		thread_state_flavor_t flavor; 4
		mach_msg_type_number_t old_stateCnt; 4
		mach_msg_trailer_t trailer; 8
	} Request __attribute__((unused)); -> 40 bytes
    typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[1296];
	} __Reply__thread_get_state_t __attribute__((unused));
 5224 bytes natural_t=4
 #define x86_DEBUG_STATE32               10
#define x86_DEBUG_STATE64               11
    """
    def thread_get_state(self,in_header, in_content):
        out_msg = MachMsg(self.ql)
        if len(in_content)==24: 
          (ndr,flavor,oldcnt,trailer)=unpack("<QIIQ",in_content)
        else:
          (ndr,flavor,oldcnt)=unpack("<QII",in_content)
        self.ql.log.debug("thread_get_state msg flavor: {} cnt: {}".format(flavor,oldcnt))
        if self.ql.arch.type==QL_ARCH.X8664:
            if flavor==x86_DEBUG_STATE32:
                self.ql.log.debug("x86_DEBUG_STATE32")
            elif flavor==x86_DEBUG_STATE64:
                self.ql.log.debug("x86_DEBUG_STATE64")
            else :
                self.ql.log.info("unimplemented thread_get_state flavor x86 {}".format(flavor))
        elif self.ql.arch.type==QL_ARCH.ARM64:
            if flavor==ARM_DEBUG_STATE32:
                self.ql.log.debug("ARM_DEBUG_STATE32")
            elif flavor==ARM_DEBUG_STATE64:
                self.ql.log.debug("ARM_DEBUG_STATE64")
            else :
                self.ql.log.info("unimplemented thread_get_state flavor arm {}".format(flavor))
        else:
            self.ql.log.info("unimplemented arch for  thread_get_state {}".format(self.ql.arch.type))
        # for now, fill oldcnt with 0s...
        out_msg.header.msgh_bits = 0
        out_msg.header.msgh_remote_port =0
        out_msg.header.msgh_voucher_port = 0
        out_msg.header.msgh_local_port = self.ql.os.macho_mach_port.name
        out_msg.header.msgh_id = in_header.msgh_id+100
        out_msg.content = pack("<Q", ndr)
        out_msg.content += pack("<L", 0x0) #retcode
        out_msg.content += pack("<L", oldcnt)
        for a in range(oldcnt):
            out_msg.content += pack("<L", 0)
        out_msg.header.msgh_size = (5224-5184)+4*oldcnt
        return out_msg
         
    """typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		task_flavor_t flavor;
		mach_msg_type_number_t task_info_outCnt;
		mach_msg_trailer_t trailer;
	} Request __attribute__((unused));
    typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t task_info_outCnt;
		integer_t task_info_out[87];
	} __Reply__task_info_t __attribute__((unused));
    """
    def task_info(self, in_header, in_content):
        out_msg = MachMsg(self.ql)
        self.ql.log.debug("in_content: {} len: {}".format(in_content,len(in_content)))
        (ndr,flavor,task_info_outCnt)=unpack("<QII",in_content)
        self.ql.log.debug("Remote task_info called: flavor: {} outcnt: {}".format(flavor,task_info_outCnt))
        out_msg.header.msgh_id = in_header.msgh_id+100
        outcnt = 87
        if task_info_outCnt<outcnt:
            outcnt= task_info_outCnt
        out_msg.header.msgh_bits = 0
        out_msg.header.msgh_remote_port =0
        out_msg.header.msgh_voucher_port = 0
        out_msg.header.msgh_local_port = self.ql.os.macho_mach_port.name
        #OutP->RetCode = task_info(In0P->Head.msgh_request_port, In0P->flavor, OutP->task_info_out, &OutP->task_info_outCnt);
	    #if (OutP->RetCode != KERN_SUCCESS) {
		#MIG_RETURN_ERROR(OutP, OutP->RetCode);
	    #}
        #OutP->NDR = NDR_record;
        out_msg.content = pack("<Q", ndr)
        out_msg.content += pack("<L", 0x0) #retcode
        out_msg.content += pack("<I", outcnt) 
        if flavor==TASK_AUDIT_TOKEN:
            for a in range(outcnt):
                out_msg.content +=pack("<I", 0x512) 
        elif flavor==TASK_EXTMOD_INFO:
            for a in range(4):
                out_msg.content +=pack("<I", 0x512) 
            for a in range(6):
                out_msg.content +=pack("<Q", 0)   
        elif flavor==TASK_DYLD_INFO:
                 self.ql.log.debug("TASK_DYLD_INFO")
                 out_msg.content +=pack("<Q", self.ql.s_all_imageinfo_addr) #all_image_info_addr
                 out_msg.content +=pack("<Q", self.ql.s_all_imageinfo_size) #all_image_info_size
                 out_msg.content +=pack("<L", 0x1)#all_image_info_format
                 out_msg.content +=pack("<L", 0x0) #padding
        else:
            raise Exception("taskinfo flavor {} unimplemented".format(flavor))

        out_msg.header.msgh_size = (388-348)+4*outcnt
        self.ql.log.debug("Remote task_info return id: {} size: {}".format(out_msg.header.msgh_id,out_msg.header.msgh_size))
        return out_msg
	    #OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply) - 348) + (((4 * OutP->task_info_outCnt)));
    """
    typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR; - 8 bytes
		exception_mask_t exception_mask;
	} __Request__task_get_exception_ports_t __attribute__((unused));
    typedef struct {
		mach_msg_header_t Head; ->size:24 byte
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body; msgh_descriptor_count
		mach_msg_port_descriptor_t old_handlers[32]; ->12 byte*32
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t masksCnt;
		exception_mask_t masks[32];
		exception_behavior_t old_behaviors[32];
		thread_state_flavor_t old_flavors[32];
	} __Reply__task_get_exception_ports_t __attribute__((unused));
    """
    def task_get_exception_ports(self,in_header, in_content):
        out_msg = MachMsg(self.ql)
        out_msg.header.msgh_id = in_header.msgh_id+100
        out_msg.header.msgh_bits = 0x80001200
        out_msg.header.msgh_remote_port = 0x00000000
        out_msg.header.msgh_local_port = self.ql.os.macho_mach_port.name
        out_msg.header.msgh_voucher_port = 0
        out_msg.content = pack("<L", 32)
        emask=unpack("<L",in_content[8:12])[0]
        self.ql.log.debug("Getting exc ports with mask {:X} ic: {}".format(emask,in_content))
        for i in range(32):
            out_msg.content+=pack("<L", 0) #port name
            out_msg.content+= pack("<L", 0x0)                                                  # pad1
            out_msg.content+= pack("<H", 0x0)                                                  # pad2
            out_msg.content+= pack("<B", 0x11)                                                 # disposition
            out_msg.content+= pack("<B", 0x0)                                                  # type
            # out_msg.content+= pack("<L", 0x0)     #pad end
           
        out_msg.trailer =bytes(in_content[:8])
        csize=(808-384)
        masksCnt=1
        out_msg.trailer+=pack("<L", masksCnt)
        msgh_size_delta=masksCnt*4
        out_msg.trailer+=pack("<L", emask)
        csize+=msgh_size_delta
        out_msg.trailer+=pack("<L", 0) #behaviors
        out_msg.trailer+=pack("<L", 0) #flavors
        csize+=msgh_size_delta*2
        out_msg.header.msgh_size = csize
        self.ql.log.debug("Message size: {}".format(out_msg.header.msgh_size))
        return out_msg

    """
        typedef struct {
            mach_msg_header_t Head;
            /* start of the kernel processed data */
            mach_msg_body_t msgh_body;
            mach_msg_port_descriptor_t special_port;
            /* end of the kernel processed data */
            NDR_record_t NDR;
            int which_port;
            mach_msg_trailer_t trailer;
        } Request __attribute__((unused)); -> 52 bytes
        typedef struct {
            mach_msg_header_t Head;
            NDR_record_t NDR;
            kern_return_t RetCode;
        } __Reply__task_set_special_port_t __attribute__((unused));
    reply -> 36 bytes
    """
    def set_special_port(self, in_header, in_content):
        out_msg = MachMsg(self.ql)
        (body,sp_name,sp_pad1,sp_pad2,sp_disp,sp_tpe,ndr,which)=unpack("<LLLHccQL",in_content[:4+12+8+4])
        self.ql.log.debug("set_special_port: ndr: 0x{:x} body: {} name: 0x{:x} which: {}".format(ndr,body,sp_name,which))
        out_msg.header.msgh_bits = 0x0001200
        out_msg.header.msgh_size = 36
        out_msg.header.msgh_remote_port = 0x00000000
        out_msg.header.msgh_local_port = self.ql.os.macho_mach_port.name
        out_msg.header.msgh_voucher_port = 0
        out_msg.header.msgh_id = in_header.msgh_id+100
        out_msg.content = pack("<Q", ndr)
        out_msg.content += pack("<L", 0) #retcode
        return out_msg

    def get_special_port(self, in_header, in_content):
        out_msg = MachMsg(self.ql)
        out_msg.header.msgh_bits = 0x80001200
        out_msg.header.msgh_size = 0x00000028
        out_msg.header.msgh_remote_port = 0x00000000
        out_msg.header.msgh_local_port = self.ql.os.macho_mach_port.name
        out_msg.header.msgh_voucher_port = 0
        out_msg.header.msgh_id = 3509

        out_msg.content = pack("<L", 0x1)

        out_msg.trailer = b''
        out_msg.trailer += pack("<L", self.ql.os.macho_port_manager.special_port.name)         # special port name 
        out_msg.trailer += pack("<L", 0x0)                                                  # pad1
        out_msg.trailer += pack("<H", 0x0)                                                  # pad2
        out_msg.trailer += pack("<B", 0x11)                                                 # disposition
        out_msg.trailer += pack("<B", 0x0)                                                  # type
        out_msg.trailer += pack("<L", 0x0)                                                  # pad end

        return out_msg
        pass
    """
    typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__task_restartable_ranges_register_t __attribute__((unused));

    """
    def restartable_ranges_register(self, in_header, in_content): #just return success
        out_msg = MachMsg(self.ql)
        out_msg.header.msgh_bits = 4608
        out_msg.header.msgh_size = 24+12
        out_msg.header.msgh_remote_port = 0x00000000
        out_msg.header.msgh_local_port = self.ql.os.macho_mach_port.name
        out_msg.header.msgh_voucher_port = 0
        out_msg.header.msgh_id = 8100
        out_msg.content += pack("<Q", 0x100000000)      # NDR
        out_msg.content += pack("<L", 0x0)              # ret code / KERN SUCCESS
            
        return out_msg
        pass